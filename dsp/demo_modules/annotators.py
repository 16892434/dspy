import dsp

def answer_and_context_match(d, program, train):
  x = dsp.Example(question=d.question, demos=dsp.all_but(train, d))
  x = program(x)
  if not dsp.passage_match(x.context, d.answer): return None
  if not dsp.answer_match(x.answer, d.answer): return None
  return d.copy(**x)

def approximate_answer_match(d, program, train):
  x = dsp.Example(question=d.question, demos=dsp.all_but(train, d))
  x = program(x)

  GeneratedAnswer = dsp.Type(prefix="Generated answer:", desc="${the answer generated by the language model}")
  TrueAnswers = dsp.Type(prefix="True answer:", desc="${a list of correct answers}")
  Response = dsp.Type(prefix="Response:", desc="${Whether generated answer is the same as at least one of true answer, either Yes or No}")

  approx_match_template = dsp.Template(
    instructions="Is the generated answer the same as at least one of the true answers? Answer only Yes or No.", 
    generated_answer=GeneratedAnswer(), 
    true_answers=TrueAnswers(),
    response=Response()
    )
  
  approx_match_example = dsp.Example(generated_answer=x.answer, true_answers=", ".join(d.answer), demos=[])
  _, completions = dsp.generate(approx_match_template)(approx_match_example, stage="lm_demo_eval")

  print(x.answer, d.answer)
  print(completions.response)

  if completions.response != "Yes": return None
  
  return d.copy(**x)
